import { ProviderRegistry } from '../src/core/registry/ProviderRegistry';

// Mock the logger
jest.mock('../src/utils/logger', () => ({
  agentLogger: {
    child: jest.fn(() => ({
      info: jest.fn(),
      warn: jest.fn(),
      error: jest.fn(),
      debug: jest.fn()
    }))
  }
}));

// Mock provider implementations for testing
interface MockProvider {
  name: string;
  initialized: boolean;
  start(): Promise<void>;
  stop(): Promise<void>;
  isHealthy(): boolean;
}

class MockLLMProvider implements MockProvider {
  name = 'mock-llm';
  initialized = false;

  async start(): Promise<void> {
    this.initialized = true;
  }

  async stop(): Promise<void> {
    this.initialized = false;
  }

  isHealthy(): boolean {
    return this.initialized;
  }
}

class MockChannelProvider implements MockProvider {
  name = 'mock-channel';
  initialized = false;

  async start(): Promise<void> {
    this.initialized = true;
  }

  async stop(): Promise<void> {
    this.initialized = false;
  }

  isHealthy(): boolean {
    return this.initialized;
  }
}

describe('ProviderRegistry', () => {
  let registry: ProviderRegistry;

  beforeEach(() => {
    registry = new ProviderRegistry();
  });

  describe('provider registration', () => {
    it('should register LLM providers', async () => {
      const provider = new MockLLMProvider();
      
      await registry.registerProvider('llm', 'mock-llm', provider);
      
      const registered = registry.getProvider('llm', 'mock-llm');
      expect(registered).toBe(provider);
    });

    it('should register channel providers', async () => {
      const provider = new MockChannelProvider();
      
      await registry.registerProvider('channel', 'mock-channel', provider);
      
      const registered = registry.getProvider('channel', 'mock-channel');
      expect(registered).toBe(provider);
    });

    it('should handle multiple providers of same type', async () => {
      const provider1 = new MockLLMProvider();
      const provider2 = new MockLLMProvider();
      provider2.name = 'mock-llm-2';
      
      await registry.registerProvider('llm', 'mock-llm-1', provider1);
      await registry.registerProvider('llm', 'mock-llm-2', provider2);
      
      expect(registry.getProvider('llm', 'mock-llm-1')).toBe(provider1);
      expect(registry.getProvider('llm', 'mock-llm-2')).toBe(provider2);
    });

    it('should reject duplicate provider names', async () => {
      const provider1 = new MockLLMProvider();
      const provider2 = new MockLLMProvider();
      
      await registry.registerProvider('llm', 'duplicate-name', provider1);
      
      await expect(
        registry.registerProvider('llm', 'duplicate-name', provider2)
      ).rejects.toThrow();
    });

    it('should validate provider types', async () => {
      const provider = new MockLLMProvider();
      
      await expect(
        registry.registerProvider('invalid-type' as any, 'test', provider)
      ).rejects.toThrow();
    });
  });

  describe('provider retrieval', () => {
    beforeEach(async () => {
      await registry.registerProvider('llm', 'test-llm', new MockLLMProvider());
      await registry.registerProvider('channel', 'test-channel', new MockChannelProvider());
    });

    it('should retrieve registered providers', () => {
      const llmProvider = registry.getProvider('llm', 'test-llm');
      const channelProvider = registry.getProvider('channel', 'test-channel');
      
      expect(llmProvider).toBeInstanceOf(MockLLMProvider);
      expect(channelProvider).toBeInstanceOf(MockChannelProvider);
    });

    it('should return undefined for non-existent providers', () => {
      const provider = registry.getProvider('llm', 'non-existent');
      expect(provider).toBeUndefined();
    });

    it('should list providers by type', () => {
      const llmProviders = registry.listProviders('llm');
      const channelProviders = registry.listProviders('channel');
      
      expect(llmProviders).toContain('test-llm');
      expect(channelProviders).toContain('test-channel');
    });

    it('should get all provider types', () => {
      const types = registry.getProviderTypes();
      
      expect(types).toContain('llm');
      expect(types).toContain('channel');
    });
  });

  describe('provider lifecycle management', () => {
    let llmProvider: MockLLMProvider;
    let channelProvider: MockChannelProvider;

    beforeEach(async () => {
      llmProvider = new MockLLMProvider();
      channelProvider = new MockChannelProvider();
      
      await registry.registerProvider('llm', 'test-llm', llmProvider);
      await registry.registerProvider('channel', 'test-channel', channelProvider);
    });

    it('should start all providers', async () => {
      await registry.startAllProviders();
      
      expect(llmProvider.initialized).toBe(true);
      expect(channelProvider.initialized).toBe(true);
    });

    it('should stop all providers', async () => {
      await registry.startAllProviders();
      await registry.stopAllProviders();
      
      expect(llmProvider.initialized).toBe(false);
      expect(channelProvider.initialized).toBe(false);
    });

    it('should start providers by type', async () => {
      await registry.startProviders('llm');
      
      expect(llmProvider.initialized).toBe(true);
      expect(channelProvider.initialized).toBe(false);
    });

    it('should stop providers by type', async () => {
      await registry.startAllProviders();
      await registry.stopProviders('llm');
      
      expect(llmProvider.initialized).toBe(false);
      expect(channelProvider.initialized).toBe(true);
    });

    it('should handle provider startup failures', async () => {
      const failingProvider = new MockLLMProvider();
      failingProvider.start = jest.fn().mockRejectedValue(new Error('Startup failed'));
      
      await registry.registerProvider('llm', 'failing-provider', failingProvider);
      
      await expect(registry.startAllProviders()).rejects.toThrow();
    });
  });

  describe('provider health monitoring', () => {
    let healthyProvider: MockLLMProvider;
    let unhealthyProvider: MockLLMProvider;

    beforeEach(async () => {
      healthyProvider = new MockLLMProvider();
      unhealthyProvider = new MockLLMProvider();
      unhealthyProvider.isHealthy = jest.fn().mockReturnValue(false);
      
      await registry.registerProvider('llm', 'healthy', healthyProvider);
      await registry.registerProvider('llm', 'unhealthy', unhealthyProvider);
      await registry.startAllProviders();
    });

    it('should check provider health', async () => {
      const healthStatus = await registry.checkProviderHealth('llm', 'healthy');
      expect(healthStatus.isHealthy).toBe(true);
      
      const unhealthyStatus = await registry.checkProviderHealth('llm', 'unhealthy');
      expect(unhealthyStatus.isHealthy).toBe(false);
    });

    it('should get health status for all providers', async () => {
      const healthReport = await registry.getHealthReport();
      
      expect(healthReport).toHaveProperty('llm');
      expect(healthReport.llm).toHaveProperty('healthy');
      expect(healthReport.llm).toHaveProperty('unhealthy');
      expect(healthReport.llm.healthy.isHealthy).toBe(true);
      expect(healthReport.llm.unhealthy.isHealthy).toBe(false);
    });

    it('should identify unhealthy providers', async () => {
      const unhealthyProviders = await registry.getUnhealthyProviders();
      
      expect(unhealthyProviders).toHaveLength(1);
      expect(unhealthyProviders[0]).toEqual({
        type: 'llm',
        name: 'unhealthy',
        status: expect.objectContaining({ isHealthy: false })
      });
    });
  });

  describe('provider unregistration', () => {
    let provider: MockLLMProvider;

    beforeEach(async () => {
      provider = new MockLLMProvider();
      await registry.registerProvider('llm', 'test-provider', provider);
      await registry.startAllProviders();
    });

    it('should unregister providers', async () => {
      await registry.unregisterProvider('llm', 'test-provider');
      
      const retrieved = registry.getProvider('llm', 'test-provider');
      expect(retrieved).toBeUndefined();
    });

    it('should stop provider before unregistering', async () => {
      await registry.unregisterProvider('llm', 'test-provider');
      
      expect(provider.initialized).toBe(false);
    });

    it('should handle unregistering non-existent providers', async () => {
      await expect(
        registry.unregisterProvider('llm', 'non-existent')
      ).rejects.toThrow();
    });
  });

  describe('provider discovery and metadata', () => {
    beforeEach(async () => {
      await registry.registerProvider('llm', 'openai', new MockLLMProvider());
      await registry.registerProvider('llm', 'anthropic', new MockLLMProvider());
      await registry.registerProvider('channel', 'slack', new MockChannelProvider());
      await registry.registerProvider('channel', 'discord', new MockChannelProvider());
    });

    it('should count providers by type', () => {
      expect(registry.getProviderCount('llm')).toBe(2);
      expect(registry.getProviderCount('channel')).toBe(2);
    });

    it('should get total provider count', () => {
      expect(registry.getTotalProviderCount()).toBe(4);
    });

    it('should check if provider exists', () => {
      expect(registry.hasProvider('llm', 'openai')).toBe(true);
      expect(registry.hasProvider('llm', 'non-existent')).toBe(false);
    });

    it('should get provider metadata', () => {
      const metadata = registry.getProviderMetadata('llm', 'openai');
      
      expect(metadata).toEqual({
        type: 'llm',
        name: 'openai',
        isRegistered: true,
        isRunning: false // Not started in this test
      });
    });
  });

  describe('error handling and edge cases', () => {
    it('should handle provider registration with null/undefined', async () => {
      await expect(
        registry.registerProvider('llm', 'null-provider', null as any)
      ).rejects.toThrow();
      
      await expect(
        registry.registerProvider('llm', 'undefined-provider', undefined as any)
      ).rejects.toThrow();
    });

    it('should handle empty provider names', async () => {
      const provider = new MockLLMProvider();
      
      await expect(
        registry.registerProvider('llm', '', provider)
      ).rejects.toThrow();
      
      await expect(
        registry.registerProvider('llm', '   ', provider)
      ).rejects.toThrow();
    });

    it('should handle concurrent registration attempts', async () => {
      const provider1 = new MockLLMProvider();
      const provider2 = new MockLLMProvider();
      
      const promises = [
        registry.registerProvider('llm', 'concurrent-1', provider1),
        registry.registerProvider('llm', 'concurrent-2', provider2)
      ];
      
      await expect(Promise.all(promises)).resolves.toBeDefined();
      
      expect(registry.getProvider('llm', 'concurrent-1')).toBe(provider1);
      expect(registry.getProvider('llm', 'concurrent-2')).toBe(provider2);
    });

    it('should handle provider failures during health checks', async () => {
      const faultyProvider = new MockLLMProvider();
      faultyProvider.isHealthy = jest.fn().mockImplementation(() => {
        throw new Error('Health check failed');
      });
      
      await registry.registerProvider('llm', 'faulty', faultyProvider);
      
      const healthStatus = await registry.checkProviderHealth('llm', 'faulty');
      expect(healthStatus.isHealthy).toBe(false);
      expect(healthStatus.error).toBeDefined();
    });
  });

  describe('registry state management', () => {
    it('should maintain registry state across operations', async () => {
      const provider1 = new MockLLMProvider();
      const provider2 = new MockChannelProvider();
      
      await registry.registerProvider('llm', 'test-1', provider1);
      await registry.registerProvider('channel', 'test-2', provider2);
      
      expect(registry.getTotalProviderCount()).toBe(2);
      
      await registry.unregisterProvider('llm', 'test-1');
      
      expect(registry.getTotalProviderCount()).toBe(1);
      expect(registry.hasProvider('llm', 'test-1')).toBe(false);
      expect(registry.hasProvider('channel', 'test-2')).toBe(true);
    });

    it('should reset registry state', async () => {
      await registry.registerProvider('llm', 'test-1', new MockLLMProvider());
      await registry.registerProvider('channel', 'test-2', new MockChannelProvider());
      
      expect(registry.getTotalProviderCount()).toBe(2);
      
      await registry.reset();
      
      expect(registry.getTotalProviderCount()).toBe(0);
      expect(registry.getProviderTypes()).toHaveLength(0);
    });

    it('should handle registry operations after reset', async () => {
      await registry.registerProvider('llm', 'test', new MockLLMProvider());
      await registry.reset();
      
      // Should be able to register new providers after reset
      const newProvider = new MockLLMProvider();
      await registry.registerProvider('llm', 'new-test', newProvider);
      
      expect(registry.getProvider('llm', 'new-test')).toBe(newProvider);
      expect(registry.getTotalProviderCount()).toBe(1);
    });
  });
});
